#include "evm_sdk.h"
#include "storage<%= options.global_config ? "_config" : "" %>.h"

% stor_namespace = options.global_config ? "config" : "stor"

namespace evm::<%= stor_namespace %> {

% ir.types.select{ _2.is_a? (StructType) }.each do |name, type|
struct <%= type.name %> {
  static constexpr unsigned FIELDS_NUM = <%= type.slots_size %>;

  <%= type.name %>(uint256_t key): <%= type.fields.map.with_index{ |x, i| x.name + '(key + ' + i.to_s + ')'}.join(', ')%> {}

%   type.fields&.each do |field|
  <%= field.type.storage_name %> <%= field.name %>;
%   end

  void clear() {
%   type.fields&.each do |field|
      <%= field.name %>.clear();
%   end
  }
};

template<__uint256_t Key>
struct <%= type.name %>Static {
  static constexpr unsigned FIELDS_NUM = <%= type.slots_size %>;
%   i = 0
%   type.fields&.each do |field|
  <%= field.type.storage_name_static(lambda{'Key + ' + i.to_s}) %> <%= field.name %>;
%   i += field.type.slots_size
%   end

  void clear() {
%   type.fields&.each do |field|
      <%= field.name %>.clear();
%   end
  }
};

% end

% i = 0
% ir.variables&.fields.each do |field|
<%= field.type.storage_name_static(i) %> <%= field.name %>;
% i += field.type.slots_size
% end

}  // namespace evm::<%= stor_namespace %>

% unless options.global_config

//namespace evm::<%= ir.namespace %>::constants {
  namespace evm::constants {

% ir.data['constants']&.each do |constant|
%   type = constant['type']
%   if constant.include?('constants')

namespace <%= constant['name'] %> {
%     constant['constants'].each do |constant|
    static constexpr uint256_t <%= constant['name'] %> = <%= constant['value'] %>;
%     end
}
%   else
static constexpr uint256_t <%= constant['name'] %> = <%= constant['value'] %>;
%   end
% end

}  // namespace evm::constants

namespace evm::ser {

% ir.types.each do |name, type|
%   next unless type.is_a?(StructType)
%   next if type.descr['flags']&.include?("storage")
struct DVM_PACKED <%= name %> {
%   if type.descr['flags']&.include?("message")
    // MessageHeader header;
%   end
%   type.fields.each do |field|
%     init = field.descr.include?('constant') ? 'evm::constants::' + field.descr['constant'] : ''
    <%= field.type.cpp_name %> <%= field.name %>{<%= init %>};
%   end
%
%   containers = type.get_container_fields
%   raise "Map types are not supported in serialization structs" unless containers.all?{ _1.type.base_type_name == 'Vector' }
    static constexpr unsigned get_size(<%= containers.map{ 'unsigned ' + _1.name }.join(', ') %>) {
%   if !containers.empty?
%   s = containers.map{ _1.type.cpp_name + '::required_size_elements(' + _1.name + ')' }
        unsigned sz = <%= s.join(' + ') %>;
        return sizeof(<%= name %>) + sz;
%   else
        return sizeof(<%= name %>);
%   end
    }
};

% end

}  // namespace evm::ser

namespace evm::contracts {

}  // evm::contracts

% end  # unless options.global_config