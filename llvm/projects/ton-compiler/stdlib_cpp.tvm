    .internal-alias :main_merge,        -4
    .internal-alias :main_split,        -3
    .internal-alias :main_ticktock,     -2
    .internal-alias :main_external,     -1
    .internal-alias :main_internal,     0
    .internal-alias :get_method,        1

; ======================================================
; Part 1. Initialization and termination of the contract
; ======================================================

    .selector
    ; s0 - func_id
    ; s1.. - other data
    SETCP0

    ; Global 5 variable: frame pointer
    PUSHINT 1000000000
    SETGLOB 5

    ; Global 14 variable: function, that emulates store into the memory by storing into the dictionary
    PUSHCONT {
        ;CALL $store_macro$
        NEWC
        PUSHINT 257 STIX
        SWAP          ; (val-b addr)
        DUP           ; (val-b addr addr)
        PUSHINT 100000
        LESS          ; (val-b addr persistent?)
        PUSHCONT {
            PUSH c4
            CTOS      ; (val-b addr dict-slice)
            PLDDICT   ; (val-b addr dict)
            PUSHINT 64
            DICTISETB ; (val-b addr dict key-width -- dict')
            NEWC STDICT ENDC
            POP c4
        }
        PUSHCONT {
            GETGLOB 1   ; ( val-b addr -- val-b addr dict )
            PUSHINT 64  ; ( val-b addr dict key-width )
            DICTISETB   ; ( val-b addr dict key-width -- c7 dict')
            SETGLOB 1
        }
        IFELSE
    }
    SETGLOB 14

    ; Global 13 variable: function, that emulates load from the memory by loading from the dictionary
    PUSHCONT {
        DUP
        PUSHINT 100000
        LESS
        PUSHCONT { PUSH c4 CTOS PLDDICT }
        PUSHCONT { GETGLOB 1 }
        IFELSE

        PUSHINT 64
        DICTIGET ; (addr dict key-width -- value-slice flag)

        ; Throw exception if key doesn't exist
        THROWIFNOT 70
        PUSHINT 257 LDIX
        ENDS
    }
    SETGLOB 13

    DUP
    ISNPOS           ; Check if func_id less than 0
    DICTPUSHCONST 32 ; Push dict with functions: {func_id: func_cont}
    ROT
    PUSHCONT {
      DICTIGETJMP    ; Get func_cont by func id and jump to it
    }
    IFJMP            ; jump to previous continuation if func id is less than 0
    BLKDROP 2

    ;; Pack arguments into a cell, that will be passed to the get method
    NEWC            ; args, func_id, builder
    DEPTH           ; args, func_id, builder, depth
    ADDCONST -2     ; args, func_id, builder, count(args)
    PUSHCONT {      ; args, func_id, builder
        XCHG s1, s2 ; args, func_id, arg, builder
        STU 256     ; args, func_id, builder
    }
    REPEAT          ; func_id, builder
    ENDC            ; func_id, packed_args

    PUSHREFCONT     ; Push getter continuation (real code will be added by Linker)
    JMPX            ; Jump to getter continuation

; ==========================================
; Part 2. C-specific functionality (runtime)
; ==========================================

; Global variables allocation (allocation of C7 tuple cells)
; GLOB 0 (FIRST)  -- Smart contract info
; GLOB 1 (SECOND) -- Global variables dictionary
